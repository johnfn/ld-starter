import { Util } from "../util";
import * as fs from 'fs';
import * as path from 'path'

const configPath = process.argv[2];
const configDirectory = path.dirname(configPath);
const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
const assetDirectory = path.join(configDirectory, config.resources.assetsPath);
const resourceFilePath = path.join(configDirectory, config.resources.compiledResourcesFile);

function maxBy<T>(list: T[], fn: (T: T) => number): T | undefined {
  let highestT    : T | undefined = undefined;
  let highestValue: number | undefined = undefined;

  for (const item of list) {
    const value = fn(item);

    if (highestValue === undefined || value > highestValue) {
      highestT = item;
      highestValue = value;
    }
  }

  return highestT;
}

function walkDir(dir: string, callback: (path: string) => void) {
  fs.readdirSync(dir).forEach((f: string) => {
    const dirPath     = path.join(dir, f);
    const isDirectory = fs.statSync(dirPath).isDirectory();

    isDirectory ? walkDir(dirPath, callback) : callback(path.join(dir, f));
  });
};

function allNestedFiles(dir: string): string[] {
  let files: string[] = [];

  walkDir(dir, path => {
    files.push(path.slice(dir.length));
  });

  return files;
}

const isPathTiledTileMap = (path: string) => {
  const json = JSON.parse(fs.readFileSync(path, 'utf8'));

  return (
    json.version && json.tilewidth && json.type === "map"
  );
};

const isPathTiledWorldMap = (path: string) => {
  const json = JSON.parse(fs.readFileSync(path, 'utf8'));

  return (
    json.maps && json.type === "world"
  );
};

const resourceExtensions = [
  '.png',
  '.gif',
  '.mp3',
  '.json',
];

const buildResourceFile = () => {
  const allFiles = allNestedFiles(assetDirectory).filter(file => resourceExtensions.find(ext => file.endsWith(ext)));
  const normalFiles: string[] = [];
  const animationBundles: { [key: string]: string[] } = {};

  for (const file of allFiles) {
    const match = /(.+)_(\d+)\.(png|gif)$/.exec(file);

    if (match === null) {
      normalFiles.push(file);
      continue;
    }

    const [fullString, prefix, frame, extension] = match;

    animationBundles[prefix] = (animationBundles[prefix] || []);
    animationBundles[prefix][Number(frame)] = file;
  }

  const allKeys = normalFiles.concat(Util.FlattenByOne(Object.keys(animationBundles).map(key => animationBundles[key])));

  let output = `// THIS FILE IS AUTOGENERATED from the parameters in config.json. Do not edit it.
// If you want to change something about how it's generated, look at library/resource_builder.ts.

import { TypesafeLoader } from "../library/typesafe_loader";

export type ResourceType =
  | "Image"
  | "TileMap"
  | "TileWorld"
  | "Audio"
  | "Spritesheet"
  | "Animation"

export type ResourceName = keyof typeof ResourcesToLoad
export type ResourcePath = 
${ allKeys.map(key => `  | "${ key }"\n`).join("") }
${ allKeys.length === 0 ? "  | void\n" : "" }

export const ResourcesToLoad = {
`

  if (allFiles.length === 0) {
    output += "  // No files found!"
    output += "}"

    return output;
  }

  const longestTruncatedFileLength = maxBy(allFiles, x => x.lastIndexOf(".") - 1)!.lastIndexOf(".") - 1;
  const longestFileLength = maxBy(allFiles, x => x.length)!.length;
  const longestResourceType = "'TileWorld'".length;

  for (const file of normalFiles) {
    let resourceType = ""

    if (file.endsWith(".png") || file.endsWith(".gif")) {
      resourceType = "Image";
    } else if (file.endsWith(".json")) {
      if (isPathTiledTileMap(path.join(assetDirectory, file))) {
        resourceType = "TileMap";
      } else if (isPathTiledWorldMap(path.join(assetDirectory, file))) {
        resourceType = "TileWorld";
      } else {
        continue;
      }
    } else if (file.endsWith(".mp3")) {
      resourceType = "Audio";
    }

    const fileNameWithoutExtension = file.slice(0, file.lastIndexOf("."));

    output += `  "${ Util.PadString(fileNameWithoutExtension, longestTruncatedFileLength, '"') }: { type: "${ Util.PadString(resourceType, longestResourceType, '"') } as const, path: "${ Util.PadString(file, longestFileLength, '"') } },\n`;
  }

  if (Object.keys(animationBundles).length > 0) {
    output += `\n`
    output += `  /* Animations */\n`
    output += `\n`

    for (const animationName of Object.keys(animationBundles)) {
      output += `  "${ animationName }": {\n`
      output += `    type: "Animation" as const,\n`;
      output += `    paths: [\n`;

      for (const frame of animationBundles[animationName]) {
        output += `      "${ frame }",\n`;
      }

      output += `    ],\n`;
      output += `  },\n`;
    }
  }

  output += "};\n";
  output += "\n"
  output += "export const Assets = new TypesafeLoader(ResourcesToLoad);\n";

  return output;
}

function writeResourceFile() {
  console.log(`[${ Util.FormatDate(new Date()) }] Recompiling...`);
  fs.writeFileSync(resourceFilePath, buildResourceFile());
}

fs.watch(
  assetDirectory, 
  { recursive: true }, 
  Util.Debounce(() => {
    writeResourceFile();
  })
);

writeResourceFile();